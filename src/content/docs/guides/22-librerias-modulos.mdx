---
title: Librer√≠as y m√≥dulos
---

## ¬øQu√© es una librer√≠a en Python?
---
Una librer√≠a o m√≥dulo en Python es un conjunto de variables, funciones y clases que se almacenan en archivos a los que podemos acceder e importar en nuestros programas para utilizar ese c√≥digo sin necesidad de desarrollarlo nosotros.

## Librer√≠as integradas:
---
Son librer√≠as vienen preinstaladas con Python y est√°n disponibles sin necesidad de instalar nada adicional. Por ejemplo:

- La librer√≠a **math**: Proporciona funciones matem√°ticas avanzadas.

- La librer√≠a **os**: Permite interactuar con el sistema operativo.

## Librer√≠as externas:
---
Estas librer√≠as tenemos que instalarlas manualmente utilizando herramientas como **pip**. Algunos ejemplos de librer√≠as externas son:

- **numpy**: Para operaciones matem√°ticas m√°s avanzadas a√∫n que math.

- **pandas**: Para an√°lisis de datos y manipulaci√≥n de tablas.

üìå Estas librer√≠as son ampliamente utilizadas dentro del mundo del dato y las veremos en profundidad a lo largo del programa.

Para instalarlas tendremos que usar el siguiente comando:

```Python
pip install numpy pandas
```

## Sintaxis b√°sica de las librer√≠as
---
La sintaxis b√°sica de las librer√≠as es sencilla. Vamos a ver dos formas:

**Importando la librer√≠a al completo:** nos permite acceder a todas sus funcionalidades como si fueran m√©todos.

- Primero importamos la librer√≠a usando import

- Usamos los m√©todos contenidos en la librer√≠a. Para usar un m√©todo de una librer√≠a nombraremos primero la librer√≠a seguida de un punto y el nombre del m√©todo que queremos usar, seguido de unos par√©ntesis dentro de los que pasaremos los argumentos necesarios.

```Python
# Importamos la libre√≠a para operaciones matem√°ticas
import math

# Definimos una variable y aplicamos el m√©todo sqrt() que calcula la ra√≠z cuadrada
numero1 = 36
raiz_numero1 = math.sqrt(numero1)
print(f'La raiz cuadrada de nuestro n√∫mero es ', raiz_numero1) 
```

La segunda manera de trabajar con una librer√≠a:

**Importando la funcionalidad o funcionalidades concretas que vayamos a usar**. Recordemos que hay que conocer la librer√≠a a trav√©s de la documentaci√≥n para saber que funcionalidades podemos necesitar.

- Primero desde la librer√≠a elegida importamos la funcionalidad que queremos usar

- Usamos la funcionalidad sin necesidad de nombrar la librer√≠a

```Python
# Importamos solo el m√©todo sqrt para calcular la ra√≠z cuadrada de la librer√≠a math
from math import sqrt

# Definimos una variable y aplicamos la funci√≥n sqrt que acabamos de imoportar
numero2 = 49
raiz_numero2 = sqrt(numero2)
print(f'la ra√≠z de nuestro numero es: ', raiz_numero2)
```

## Ventajas de las librer√≠as:
---
**Reutilizaci√≥n de c√≥digo:** Las librer√≠as nos proporcionan funciones y clases que podemos usar en diferentes proyectos sin necesidad de volver a escribir el c√≥digo desde cero. Esto ahorra tiempo y esfuerzo en el desarrollo de software.

- **Facilidad de desarrollo**: Las librer√≠as encapsulan funcionalidades complejas en funciones simples de usar, lo que facilita la implementaci√≥n de tareas espec√≠ficas. Esto permite a los desarrolladores concentrarse en la l√≥gica de negocio de su aplicaci√≥n en lugar de preocuparse por detalles de implementaci√≥n.

- **Eficiencia y rendimiento**: Las librer√≠as est√°n escritas y optimizadas, lo que mejora el rendimiento (es m√°s √≥ptimo y eficiente en comparaci√≥n con implementaciones personalizadas).

- **Mantenimiento simplificado**: Al utilizar librer√≠as bien mantenidas y ampliamente utilizadas, nos beneficiamos de actualizaciones regulares, correcciones de errores y mejoras de rendimiento proporcionadas por la comunidad de c√≥digo abierto.

- **Escalabilidad y extensibilidad**: Las librer√≠as nos permiten escalar nuestro c√≥digo f√°cilmente agregando nuevas funcionalidades o integrando tecnolog√≠as adicionales.

- **Documentaci√≥n y soporte**: Las librer√≠as populares suelen estar bien documentadas, lo que nos facilita su aprendizaje y uso.

## M√≥dulo datetime
---
La librer√≠a datetime nos permite manipular fechas y horas de una manera flexible y f√°cil de usar. Aunque la implementaci√≥n permite operaciones aritm√©ticas con fechas y horas, su principal objetivo es poder extraer campos de manera eficiente para su posterior manipulaci√≥n o formateo.

- **Clases proporcionadas**: El m√≥dulo datetime proporciona varias clases, incluyendo **datetime**, **date**, **time**, **timedelta**, y **tzinfo**.

- **Operaciones con fechas y horas**: El m√≥dulo **datetime** permite realizar una variedad de operaciones con fechas y horas, como sumar y restar objetos de fecha y hora, obtener la fecha y hora actuales, formatear y analizar cadenas de fecha y hora, y manejar zonas horarias.

## M√≥dulo datetime: m√©todo datetime
---
Primero importamos la librer√≠a con el m√©todo **import**. Recordemos que los import deben estar al principio de nuestro archivo y solo es necesario hacer el **import** una vez.

Vamos a usar el m√©todo **datetime** que nos permite usar combinaciones de **fecha** y **hora**. Recordamos que primero nombramos la librer√≠a seguida de un punto y el nombre del m√©todo que queremos usar. En este caso la librer√≠a y el m√©todo se llaman de la misma manera: **datetime**

En este ejemplo, el primer datetime hace referencia al m√≥dulo, el segundo al m√©todo llamado igual y los n√∫meros dentro del par√©ntesis, los argumentos del m√©todo, son el a√±o, el mes, el d√≠a y la hora exacta.

```Python
import datetime

# Creamos un objeto datetime con una fecha y hora espec√≠ficas. A√±o, mes, d√≠a, hora, min, segundo)
fecha_hora_especifica = datetime.datetime(1495, 2, 14, 12, 30, 0)
print("Fecha y hora espec√≠fica:", fecha_hora_especifica)
# Output esperado: Fecha y hora espec√≠fica: 1495-02-14 12:30:00
```

## M√≥dulo datetime: m√©todo now
---
El m√©todo **now()** nos permite acceder a la fecha y hora exactas de nuestro ordenador:

```Python
# Creamos un objeto datetime con la fecha y hora actual
fecha_hora_actual = datetime.datetime.now()
# Primero la librer√≠a.luego el m√©todo usado. now() otro m√©todo que hace referencia a ahora mismo

print("Fecha y hora actual:", fecha_hora_actual)
```

## M√≥dulo datetime: m√©todo date
---
El m√©todo **date** nos permite trabajar solo con la fecha y no la hora:

```Python
# Creamos un objeto date con la fecha actual
fecha_hoy = datetime.date.today()
print("Fecha hoy: ", fecha_hoy)

# Creamos un objeto date con una fecha concreta
fecha_especifica = datetime.date(1495, 12, 31)
print("Fecha espec√≠fica: ", fecha_especifica)
```

## M√≥dulo datetime: m√©todo time
---
Al contrario que el m√©todo date, el m√©todo **time** nos permite trabajar solo con la hora:

```Python
# Creamos un objeto time con la hora

hora = datetime.time.datetime.now().time()
print("La hora es: ", hora)

hora_elegida = datetime.time(23, 14, 56)
print("La hora concreta es: ", hora_elegida)
```

## M√≥dulo datetime: m√©todo strftime
---
Podemos usar **strftime** para cambiar el formato de a√±o, mes, d√≠a:

```Python
# Obtenemos la fecha y hora actual
fecha_hora_actual = datetime.datetime.now()
print("La fecha sin formatear es :", fecha_hora_actual)

# Formateamos la fecha y hora en un formato espec√≠fico
fecha_hora_formateada = fecha_hora_actual.strftime("%Y-%m-%d %H:%M:%S")
print("Fecha y hora formateada:", fecha_hora_formateada)

# Formateamos solo la fecha en otro formato
fecha_formateada = fecha_hora_actual.date().strftime("%d/%m/%Y")
print("Fecha formateada:", fecha_formateada)

# Formateamos solo la hora en otro formato
hora_formateada = fecha_hora_actual.time().strftime("%H:%M:%S")
print("Hora formateada:", hora_formateada)
```

## M√≥dulo datetime: m√©todo timedelta
---
Podemos usar timedelta para calcular fechas:

```Python
# Obtenemos la fecha actual
fecha_actual = datetime.date.today()
print("Fecha y hora actual:", fecha_hora_actual)

# Calculamos la fecha de hace una semana
fecha_hace_una_semana = fecha_actual - datetime.timedelta(days=7)
print("Fecha de hace una semana:", fecha_hace_una_semana)

# Calculamos la fecha de dentro de tres meses
fecha_dentro_de_tres_meses = fecha_actual + datetime.timedelta(days=90)
print("Fecha de dentro de tres meses:", fecha_dentro_de_tres_meses)
```

Aparte de estas funcionalidades existen muchas otras que pod√©is encontrar en la documentaci√≥n oficial que ten√©is en este [link](https://docs.python.org/3/library/datetime.html).

## M√≥dulo os
---
El m√≥dulo **os** en Python nos proporciona funciones para interactuar con el sistema operativo en el que se ejecuta Python. Podemos realizar tareas como manipulaci√≥n de archivos y directorios, obtener informaci√≥n sobre el entorno del sistema, manipular rutas de archivos, entre otros.

Recordamos que antes de empezar a usar un m√≥dulo importamos la librer√≠a o **os**. Recordemos que los import deben estar al principio de nuestro archivo y solo es necesario hacer el **import** una vez.

```python
import os
```

## M√≥dulo os: m√©todo open() y close()
---
Podemos abrir un archivo en bajo nivel con el m√©todo **open()**, lo cual devuelve un descriptor de archivo. Este descriptor lo utilizamos para operaciones como leer o escribir.

Para cerrarlo usaremos el m√©todo **close()**.

üìç Recuerda cambiar los argumentos por el nombre del archivo con el que vayas a trabajar

```python
# Abre el archivo 'archivo.txt'
archivo_abrir = os.open('archivo.txt')
print("Descriptor de archivo:", archivo_abrir)

# Cierra el archivo despu√©s de la operaci√≥n
os.close(archivo_abrir)
```

## M√≥dulo os: m√©todo read() y decode()
---
Podemos leer el contenido de un archivo abierto en bajo nivel utilizando el descriptor y el m√©todo **os.read()**. Este m√©todo lee n bytes del archivo, para convertir es bytes a a una cadena de texto usaremos el m√©todo **decode()**

üìç Recuerda cambiar los argumentos por el nombre del archivo con el que vayas a trabajar

```python
# Abrimos el archivo 'archivo.txt'
archivo_leer = os.open('archivo.txt')

# Leemos los primeros 100 bytes del archivo
lectura = os.read(archivo_leer, 100)
print("Contenido le√≠do:", lectura.decode())

# Cerramos el archivo despu√©s de la operaci√≥n
os.close(fd)
```

## M√≥dulo os: m√©todo getcwd()
---
El m√©todo getcwd() nos permite acceder al directorio de trabajo actual:

```python
directorio_actual = os.getcwd()
print("Directorio de trabajo actual:", directorio_actual)
```

## M√≥dulo os: m√©todo chdir()
---
El m√©todo **chdir()** nos permite cambiar el directorio de trabajo:

üìçEn el ejemplo es importante cambiar el string de la variable nuevo_directorio por una ruta existente en tu ordenador.

```python
# Cambiar al directorio especificado
nuevo_directorio = '/ruta/al/nuevo/directorio'
os.chdir(nuevo_directorio)

# Verificar el cambio
print("Nuevo directorio de trabajo:", os.getcwd())
```

## M√≥dulo os: m√©todo listdir()
---
Mediante el m√©todo **listdir()** podemos listar los archivos y directorios en un directorio espec√≠fico:

üìçEn el ejemplo es importante cambiar el string de la variable nuevo_directorio por una ruta existente en tu ordenador.

```python
directorio = '/ruta/al/directorio'
archivos_y_directorios = os.listdir(directorio)
print("Archivos y directorios en", directorio, ":", archivos_y_directorios)
```

## M√≥dulo os: m√©todo mkdir()
---
El m√©todo **mkdir()** para crear un nuevo directorio en una ruta especificada:

```python
nuevo_directorio = '/ruta/al/nuevo/directorio'
os.mkdir(nuevo_directorio)
```

## M√≥dulo os: m√©todo remove()
---
Al contrario que e m√©todo anterior, podemos eliminar un archivo indicando su nombre, y su ruta si fuera necesario, usando el m√©todo **remove()**.

```python
archivo_a_eliminar = 'archivo_a_eliminar.txt'
os.remove(archivo_a_eliminar)
```

## M√≥dulo os: m√©todo rmdir()
---
Si queremos eliminar un directorio, una carpeta, podemos usar el m√©todo **rmdir()**

```python
directorio_a_eliminar = '/ruta/al/directorio_a_eliminar'
os.rmdir(directorio_a_eliminar)
```

## M√≥dulo os: m√©todo path.exists()
---
Usaremos este m√©todo para verificar si un archivo existe. Podemos a√±adir un bloque if para mostrar un mensaje si existe o si no existe:
```python
archivo_o_directorio = '/ruta/al/archivo_o_directorio'
if os.path.exists(archivo_o_directorio):
    print(archivo_o_directorio, "existe")
else:
    print(archivo_o_directorio, "no existe")
```

## M√≥dulo os: m√©todo path.join()
---
Podemos unir partes de rutas de archivos con el m√©todo **path.join()**. Esto nos permite crear rutas completas.

```python
ruta_base = '/ruta/base'
archivo = 'archivo.txt'
ruta_completa = os.path.join(ruta_base, archivo)
print("Ruta completa:", ruta_completa)
```

Aparte de estas funcionalidades existen muchas otras que pod√©is encontrar en la documentaci√≥n oficial que ten√©is en este [link](https://docs.python.org/3/library/os.html).

## Manejo de ficheros
---
En Python, trabajar con ficheros es una tarea com√∫n. En esta unidad did√°ctica, veremos algunos detalles sobre c√≥mo se puede trabajar con ficheros en Python. Algunas funciones son muy similares a las vistas en el m√≥dulo **os**.

## Manejo de ficheros: abrir un fichero
---
Podemos usar la funci√≥n **open()** para abrir un fichero. Esta funci√≥n devuelve un objeto fichero que puedes usar para leer, escribir y manipular m√°s tarde.

En este ejemplo estamos pasando como argumentos de la funci√≥n open(), la ruta de un archivo txt y el segundo argumento, la "r" , abre el fichero en modo lectura.

üìç Recuerda cambiar los argumentos por el nombre del archivo con el que vayas a trabajar

```python
# Abrimos el fichero 'mi_fichero.txt' en modo de lectura
fichero_abrir = open('mi_fichero.txt', 'r')
```

## Manejo de ficheros: leer un fichero
---
Usamos el m√©todo **read()** para leer todo el contenido de un fichero. Si queremos leer solo una l√≠nea usamos el m√©todo **readline()**.

üìç Recuerda cambiar los argumentos por el nombre del archivo con el que vayas a trabajar

```python
# Abrimos el fichero 'mi_fichero.txt' en modo de lectura
fichero_abrir = open('mi_fichero.txt', 'r')
# Leemos todo el contenido del fichero
contenido = fichero_abrir.read()
# Lee una l√≠nea del fichero
linea = fichero_abrir.readline()
```

## Manejo de ficheros: escribir en un fichero
---
Usamos el m√©todo **write()** para escribir en un fichero. Recuerda abrir el fichero en modo de escritura (w) o en modo de a√±adir (a) en vez de en modo lectura(r) como hasta ahora.

üìç Recuerda cambiar los argumentos por el nombre del archivo con el que vayas a trabajar

```python
# Abrimos el fichero 'mi_fichero.txt' en modo de escritura
fichero_escritura = open('mi_fichero.txt', 'w')

# Escribimos en el fichero
fichero_escritura.write("Hola, mundo!")
```

## Manejo de ficheros: cerrar un fichero
---
Usamos el m√©todo **close()** para cerrar un fichero. Es importante cerrar los ficheros despu√©s de usarlos para liberar recursos del sistema.

üìç Recuerda cambiar los argumentos por el nombre del archivo con el que vayas a trabajar.

```python
# Abrimos un archivo con la funci√≥n open
file = open('mi_fichero.txt', 'w)
# Cerramos el fichero
file.close()
```
